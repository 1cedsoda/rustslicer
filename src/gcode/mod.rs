//! G-code generation module

use crate::config::PrintProfile;
use crate::error::Result;
use crate::slicer::Layer;
use std::fs::File;
use std::io::Write;
use std::path::Path;

pub struct GCodeGenerator {
    config: PrintProfile,
    total_extrusion: f64,
}

impl GCodeGenerator {
    pub fn new(config: PrintProfile) -> Self {
        Self {
            config,
            total_extrusion: 0.0,
        }
    }

    pub fn generate(&mut self, layers: &[Layer], output_path: &Path) -> Result<()> {
        log::info!("Generating G-code to {:?}", output_path);

        let mut file = File::create(output_path)?;

        // Write header
        writeln!(file, "{}", self.generate_header())?;

        // Generate layers
        for (idx, layer) in layers.iter().enumerate() {
            if layer.islands.is_empty() {
                continue;
            }

            writeln!(file, "; Layer {} at Z={:.3}", idx, layer.z_height)?;
            writeln!(file, "G0 Z{:.3} ; Move to layer height", layer.z_height)?;

            // For now, just add placeholder paths
            // In a full implementation, this would generate actual toolpaths
            for (island_idx, island) in layer.islands.iter().enumerate() {
                writeln!(file, "; Island {}", island_idx)?;
                // Generate perimeter paths
                self.generate_perimeter_gcode(&mut file, &island.outline)?;
            }
        }

        // Write footer
        writeln!(file, "{}", self.generate_footer())?;

        log::info!("G-code generation complete");
        Ok(())
    }

    fn generate_header(&self) -> String {
        // Get values with fallbacks
        let material_name = self.config.filament.as_ref()
            .map(|f| f.filament_type.as_str())
            .or_else(|| self.config.material.as_ref().map(|m| m.material_type.as_str()))
            .unwrap_or("Unknown");
        
        let layer_height = self.config.get_layer_height();
        let infill_density = self.config.get_infill_density();
        
        let infill_pattern = self.config.infill.as_ref()
            .map(|i| format!("{:?}", i.infill_pattern))
            .or_else(|| self.config.print_settings.as_ref().map(|ps| format!("{:?}", ps.infill_pattern)))
            .unwrap_or_else(|| "Gyroid".to_string());
        
        let perimeters = self.config.quality.as_ref()
            .map(|q| q.perimeters)
            .or_else(|| self.config.print_settings.as_ref().map(|ps| ps.perimeters))
            .unwrap_or(3);

        let nozzle_temp = self.config.filament.as_ref()
            .map(|f| f.temperature)
            .or_else(|| self.config.material.as_ref().map(|m| m.nozzle_temperature))
            .unwrap_or(200);

        let bed_temp = self.config.filament.as_ref()
            .map(|f| f.bed_temperature)
            .or_else(|| self.config.material.as_ref().map(|m| m.bed_temperature))
            .unwrap_or(60);

        let mut header = vec![
            "; ═══════════════════════════════════════════════".to_string(),
            "; Generated by RustSlicer".to_string(),
            format!("; Profile: {}", self.config.metadata.profile_name),
            format!("; Material: {}", material_name),
            format!("; Layer height: {:.2}mm", layer_height),
            format!("; Infill: {}% {}", (infill_density * 100.0) as u8, infill_pattern.to_lowercase()),
            format!("; Perimeters: {}", perimeters),
            "; ═══════════════════════════════════════════════".to_string(),
            String::new(),
        ];

        // Add custom start G-code
        if !self.config.gcode.start_gcode.is_empty() {
            header.push("; Start G-code".to_string());
            header.push(self.config.gcode.start_gcode.clone());
        }

        // Initial setup commands
        header.push("; Initialize printer".to_string());
        
        if self.config.gcode.use_relative_e {
            header.push("M83 ; Relative extrusion mode".to_string());
        } else {
            header.push("M82 ; Absolute extrusion mode".to_string());
        }
        
        header.push(format!("M104 S{} ; Set hotend temperature", nozzle_temp));
        header.push(format!("M140 S{} ; Set bed temperature", bed_temp));
        header.push(format!("M109 S{} ; Wait for hotend", nozzle_temp));
        header.push(format!("M190 S{} ; Wait for bed", bed_temp));
        header.push("G92 E0 ; Reset extruder".to_string());
        header.push("G90 ; Absolute positioning".to_string());
        header.push(String::new());

        header.join("\n")
    }

    fn generate_footer(&self) -> String {
        let mut footer = vec![
            String::new(),
            "; ═══════════════════════════════════════════════".to_string(),
            "; End of print".to_string(),
            "; ═══════════════════════════════════════════════".to_string(),
        ];

        // Add custom end G-code
        if !self.config.gcode.end_gcode.is_empty() {
            footer.push("; End G-code".to_string());
            footer.push(self.config.gcode.end_gcode.clone());
        } else {
            // Default end sequence
            footer.push("M104 S0 ; Turn off hotend".to_string());
            footer.push("M140 S0 ; Turn off bed".to_string());
            footer.push("G91 ; Relative positioning".to_string());
            footer.push("G1 E-2 F2700 ; Retract".to_string());
            footer.push("G1 Z10 ; Raise Z".to_string());
            footer.push("G90 ; Absolute positioning".to_string());
            footer.push("G28 X Y ; Home X Y".to_string());
            footer.push("M84 ; Disable motors".to_string());
        }

        footer.join("\n")
    }

    fn generate_perimeter_gcode(&mut self, file: &mut File, polygon: &crate::geometry::Polygon) -> Result<()> {
        if polygon.points.is_empty() {
            return Ok(());
        }

        // Move to first point
        let first = &polygon.points[0];
        writeln!(file, "G0 X{:.3} Y{:.3} ; Move to perimeter start", first.x, first.y)?;

        // Trace perimeter
        for point in &polygon.points[1..] {
            writeln!(file, "G1 X{:.3} Y{:.3} ; Perimeter", point.x, point.y)?;
        }

        // Close the loop
        writeln!(file, "G1 X{:.3} Y{:.3} ; Close perimeter", first.x, first.y)?;

        Ok(())
    }
}
